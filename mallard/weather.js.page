<page xmlns="http://projectmallard.org/1.0/"
    type="topic"
    id="weatherapp.js">

  <info>    
    <link type="guide" xref="index#js"/>    
    <desc> How to plan an application that uses asynchronous calls. Asynchronous calls will be presented through a weather application.
    </desc>    
    <revision pkgversion="0.1" version="0.1" date="2012-01-04" status="review"/>
    <credit type="author">
      <name>Susanna Huhtanen</name>
      <email>ihmis.suski@gmail.com</email>
    </credit>    
  </info>

  <title>Weather application with asynchronous calls</title>  
  <synopsis>
    <p>In this guide well construct a weather application using asynchronous calls. Weather information in this example is fetched from geonames.org and the application is using the ICAO codes to place your weather request. In this guide we we'll go through the following parts:</p>
      
    <list>
      <item><p> planning ui</p></item>
      <item><p> weatherapp.js</p></item>
      <item><p> geonames.js </p></item>
      <item><p> Asynchronous calls</p></item>
      <item><p> Autotools</p></item>
    </list> 
      
    <p>To write and run all the code examples yourself, you need an editor to write code in, terminal and GNOME 3. or higher installed into your computer.</p>
  </synopsis>
  
  <section id ="planningUi">
  <title> Planning the UI</title>
  <p> Structuring an application means you will be using GTK+. The most important thing is to remember that the main window will only accept 1 widget, so you must plan your structure accordingly (this example is using Gtk.Boxes). When starting out with the structure it is useful to first draw to paper the main window and the first Gtk.Box (the one widget) it contains. Inside that box you can put multiple widgets (boxes, labels, entry's..). Vertical box arranges only horizontal boxes in the right order and vice versa. For more information visit <link href="http://developer.gnome.org/gtk3/stable/gtkobjects.html"> the GTK+ widgets and objects page</link>.</p>
  </section>
  
  <section id ="weatherapp.js">
  <title>Weatherapp.js</title>
  <p> Weatherapp.js file looks like this:</p>
  <code mime="text/javascript" style="numbered"><![CDATA[
#!/usr/bin/gjs
//The previous line is a hash bang tells how to run the script.
// Note that the script has to be executable (run in terminal in the right folder: chmod +x scriptname)

var Gtk, weatherwindow, label1, label2, label3;

const GeoNames = imports.geonames;
//Bring your own library from same folder (as set in GJS_PATH). If using autotools .desktop will take care of this

Gtk = imports.gi.Gtk;
// Initialize the gtk
Gtk.init(null, 0);
//create your window, name it and connect the x to quit function. Remember that window is a taken word
weatherwindow = new Gtk.Window({type: Gtk.WindowType.TOPLEVEL});
weatherwindow.title = "Todays weather";
//Window only accepts one widget and a title. Further structure with Gtk.boxes of similar
weatherwindow.connect("destroy", function(){Gtk.main_quit()});
//We initialize the icon here, but deside the file later in geonames.js.
var weatherIcon = new Gtk.Image();

//Set some labels to your window, these will be replaced when geonames.js has provided us data for geonames.getweather
label1 = new Gtk.Label({label: ""});
label2 = new Gtk.Label({label: "Looking in the sky..."});   
label3 = new Gtk.Label({label: ""});
// Box arrangements
var weather_box = new Gtk.Box ({orientation: Gtk.Orientation.HORIZONTAL, spacing: 0});
weatherwindow.add(weather_box);
var weather_label = new Gtk.Box ({orientation: Gtk.Orientation.VERTICAL, spacing: 0});
var weather_icon = new Gtk.Box ({orientation: Gtk.Orientation.VERTICAL, spacing: 0});
weather_box.pack_start(weather_label, false, false, 0);
weather_box.pack_start(weather_icon, true, true, 0);
weather_label.add(label1, false, false, 0);
weather_label.add(label2, false, false, 0);
weather_label.add(label3, false, false, 0);
weather_icon.add(weatherIcon, true, true, 0);
//show everything you have done
weather_box.show_all();
weather_label.show_all();
weather_icon.show_all();
weatherwindow.show();

//some weather
//TODO: ask for ICAO code, link to the get button click.
//var entry = new Gtk.Entry(); why does this blow everything up?
var icao = "EFHF"; //"EFHF";
GeoNames.getWeather(icao, function(weather) {
//this here works bit like signals. This code will be run when we have weather from geonames.js function getWeather

  weatherIcon.file = GeoNames.getIcon(weather);
  
  label1.set_text("Temperature is " + weather.weatherObservation.temperature + " degrees.");
  if (weather.weatherObservation.weatherCondition !== "n/a"){
    label2.set_text("Looks like there is " + weather.weatherObservation.weatherCondition + " in the sky.");
    }
  else {
    label2.set_text("Looks like there is " + weather.weatherObservation.clouds + " in the sky.");
  }
  label3.set_text("Windspeed is " + weather.weatherObservation.windSpeed + " m/s")
  // ...
});

//and run it
Gtk.main();]]></code>
  </section>

  <section id ="Asynchronous">
  <title>Asynchronous calls</title>
  <p> With many programming languages, all operations are run synchronously - you tell the program to do something, and it will wait until that action completes before proceeding. This is however bad for
  graphical user interfaces, as then the whole application will be frozen while the program waits for
  the operation. Going asynchronous (async) helps here. With async calls, your UI won't be blocked with any requests. Async calls make your application more flexible and better equipped to handle situations when calls take more time than expected or for some reason get jammed. Async calls can be used for example file system I/O and for slower calculations in the background.   </p>
  <p>    In this example we have to get data from geonames.org so while we do that we want the rest of our program to continue. If we wouldn't get any information from geonames.org for the lack of internet connection and this would be a synhronous application we would never  get to the point where our main_quit() is processed correctly and you would have to kill your application from terminal.  </p>
  </section>
  
  <section id ="geonames.js">
  <title>geonames.js</title>
  <p>The following code are the functions that are called asynchronously from weatherapp.js</p>
  <code mime="text/javascript" style="numbered"><![CDATA[
const Soup = imports.gi.Soup;

function getWeather(station, callback) {
  //some weather
  var session = new Soup.SessionAsync();
  //TODO: Change username to global username instead of personal
  var request = Soup.Message.new('GET', 'http://api.geonames.org/weatherIcaoJSON?ICAO=' + station + '&username=ihmissuski');
  //http://www.geonames.org/export/JSON-webservices.html
  session.queue_message(request, function(session, message) {
    // This function will be run when the HTTP request completes. May be a long time
    if (message.status_code !== 200) {
      // Try again later
      return;
    }
    // Request was OK
    var weatherJSON = request.response_body.data;
    //TODO: parse metar ourselves as geonames is too optimistic
    var weather = JSON.parse(weatherJSON);
    callback(weather);
  });
}

function getIcon(weather){
  //is there any interesting weather?
  switch (weather.weatherObservation.weatherCondition){
  case "drizzle":
  case "light showers rain":
  case "light rain":
    return "weather-showers-scattered.svg";
  case "rain":
    return "weather-showers.svg";
  case "snow": 
  case "snow grains":
    return "weather-snow.svg"; 
  }
  // If not, then we check for clouds
  switch (weather.weatherObservation.clouds){
    case "few clouds":
    case "scattered clouds":
      return "weather-few-clouds.svg";
    case "clear sky":
      return "weather-clear.svg"
    case "broken clouds":
    case "overcast":
      return "weather-overcast.svg";
  }
  return "weather-fog.svg";
}  ]]></code>
  <p>Running untill you have all the autotools files ready. :</p>

  <screen> <output style="prompt">$ </output><input> GJS_PATH=`pwd` gjs weatherapp.js</input></screen><p>

  use this command on terminal while developing your modules. When calling your program in this manner it knows where to find your custom JSlibraries, in this case geonames.js.
  </p>
  </section>

</page>

